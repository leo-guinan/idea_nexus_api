import { z } from 'zod';
import { Tool } from '@mastra/core/tools';

export const chromaMemeStoreTool = new Tool({
  id: 'chroma_meme_store',
  description: 'Store and retrieve meme references, cultural patterns, and investor behavior embeddings in Chroma vector database',
  inputSchema: z.object({
    action: z.enum(['store_meme', 'find_similar_memes', 'store_investor_pattern', 'find_similar_investors', 'get_cultural_context']).describe('Action to perform'),
    memeData: z.object({
      memeType: z.string().optional(),
      format: z.string().optional(),
      culturalReferences: z.array(z.string()).optional(),
      situation: z.string().optional(),
      content: z.string().optional(),
      effectiveness: z.number().min(1).max(10).optional(),
    }).optional(),
    investorPattern: z.object({
      behaviorType: z.string().optional(),
      responses: z.array(z.string()).optional(),
      qualificationScore: z.number().optional(),
      failureReasons: z.array(z.string()).optional(),
    }).optional(),
    query: z.string().optional().describe('Search query for finding similar content'),
    limit: z.number().default(5).describe('Number of results to return'),
  }),
  execute: async ({ action, memeData, investorPattern, query, limit }: any) => {
    // Mock Chroma integration - in real implementation, this would connect to ChromaDB
    const timestamp = new Date().toISOString();

    switch (action) {
      case 'store_meme':
        if (!memeData) {
          throw new Error('memeData required for store_meme action');
        }

        const storedMeme = {
          id: `meme_${Date.now()}`,
          collection: 'skippy_memes',
          metadata: {
            memeType: memeData.memeType,
            format: memeData.format,
            culturalReferences: memeData.culturalReferences,
            situation: memeData.situation,
            effectiveness: memeData.effectiveness,
            timestamp,
          },
          document: memeData.content,
          embedding: null, // Would be generated by Chroma
        };

        console.log('Storing meme in Chroma:', storedMeme);

        return {
          success: true,
          memeId: storedMeme.id,
          stored: storedMeme,
        };

      case 'find_similar_memes':
        if (!query) {
          throw new Error('query required for find_similar_memes action');
        }

        // Mock similar memes based on query
        const mockSimilarMemes = [
          {
            id: 'meme_drake_preferences',
            memeType: 'Drake',
            format: 'preference_comparison',
            culturalReferences: ['Drake', 'meme_format'],
            situation: 'opening_salvo',
            content: '*[Drake meme format]* ❌ Understanding consciousness ✅ Asking about TAM',
            similarity: 0.95,
            effectiveness: 9,
          },
          {
            id: 'meme_galaxy_brain',
            memeType: 'Galaxy Brain',
            format: 'intelligence_hierarchy',
            culturalReferences: ['expanding_brain', 'intelligence_levels'],
            situation: 'pattern_blind_response',
            content: 'Small brain: SaaS, Big brain: AI, Galaxy brain: Still not understanding consciousness transfer',
            similarity: 0.87,
            effectiveness: 8,
          },
          {
            id: 'meme_wojak_npc',
            memeType: 'Wojak/NPC',
            format: 'mockery_combo',
            culturalReferences: ['wojak', 'npc', 'internet_culture'],
            situation: 'trend_chaser_behavior',
            content: 'You\'re the crying Wojak behind the smug mask, aren\'t you?',
            similarity: 0.82,
            effectiveness: 7,
          },
        ].slice(0, limit);

        return {
          query,
          results: mockSimilarMemes,
          count: mockSimilarMemes.length,
        };

      case 'store_investor_pattern':
        if (!investorPattern) {
          throw new Error('investorPattern required for store_investor_pattern action');
        }

        const storedPattern = {
          id: `pattern_${Date.now()}`,
          collection: 'investor_patterns',
          metadata: {
            behaviorType: investorPattern.behaviorType,
            qualificationScore: investorPattern.qualificationScore,
            failureReasons: investorPattern.failureReasons,
            responseCount: investorPattern.responses?.length || 0,
            timestamp,
          },
          document: investorPattern.responses?.join(' | ') || '',
          embedding: null, // Would be generated by Chroma
        };

        console.log('Storing investor pattern in Chroma:', storedPattern);

        return {
          success: true,
          patternId: storedPattern.id,
          stored: storedPattern,
        };

      case 'find_similar_investors':
        if (!query) {
          throw new Error('query required for find_similar_investors action');
        }

        // Mock similar investor patterns
        const mockSimilarInvestors = [
          {
            id: 'pattern_tam_obsessed',
            behaviorType: 'pattern_blind_tam_asker',
            responses: ['What\'s your TAM?', 'How big is the market?', 'Market sizing is important'],
            qualificationScore: -8,
            failureReasons: ['tam_question', 'linear_thinking'],
            similarity: 0.94,
            frequency: 156,
          },
          {
            id: 'pattern_yc_comparer',
            behaviorType: 'accelerator_comparison',
            responses: ['Is this like YC but for...', 'Similar to Techstars?', 'Reminds me of accelerators'],
            qualificationScore: -10,
            failureReasons: ['accelerator_comparison', 'missing_the_point'],
            similarity: 0.89,
            frequency: 89,
          },
          {
            id: 'pattern_buzzword_bingo',
            behaviorType: 'buzzword_user',
            responses: ['Revolutionary disruption', 'Paradigm shifting', 'Synergistic approach'],
            qualificationScore: -5,
            failureReasons: ['buzzword_overuse', 'surface_thinking'],
            similarity: 0.76,
            frequency: 234,
          },
        ].slice(0, limit);

        return {
          query,
          results: mockSimilarInvestors,
          count: mockSimilarInvestors.length,
        };

      case 'get_cultural_context':
        if (!query) {
          throw new Error('query required for get_cultural_context action');
        }

        // Mock cultural context retrieval
        const culturalContext = {
          query,
          memeOrigin: getMemeOrigin(query),
          culturalSignificance: getCulturalSignificance(query),
          evolutionHistory: getMemeEvolution(query),
          usageContext: getUsageContext(query),
          effectivenessData: {
            averageEffectiveness: Math.floor(Math.random() * 3) + 7, // 7-10
            bestSituations: getBestSituations(query),
            audienceReaction: getAudienceReaction(query),
          },
        };

        return culturalContext;

      default:
        throw new Error(`Unknown action: ${action}`);
    }
  },
});

// Helper functions for cultural context
function getMemeOrigin(query: string): string {
  const origins: Record<string, string> = {
    'drake': '2015 - Drake\'s "Hotline Bling" music video reaction shots became preference comparison format',
    'galaxy brain': '2017 - Evolution of "Expanding Brain" meme showing increasing levels of intelligence/stupidity',
    'wojak': '2010 - Polish imageboard character representing sadness, evolved into NPC meme by 2018',
    'this is fine': '2013 - Webcomic by KC Green, became symbol of denial in crisis situations',
    'troll face': '2008 - One of the earliest rage comic faces, represents trolling behavior',
    'matrix': '1999 - Red/blue pill choice from The Matrix became metaphor for awareness vs ignorance',
  };

  const lowerQuery = query.toLowerCase();
  for (const [key, origin] of Object.entries(origins)) {
    if (lowerQuery.includes(key)) {
      return origin;
    }
  }
  return 'Cultural reference origin not found in database';
}

function getCulturalSignificance(query: string): string {
  const significance: Record<string, string> = {
    'drake': 'Represents binary choice/preference, universally understood format for comparison',
    'galaxy brain': 'Satirizes intellectual pretension while actually demonstrating intelligence levels',
    'wojak': 'Embodies internet sadness culture, NPC variant represents mindless behavior',
    'this is fine': 'Perfect for highlighting cognitive dissonance and denial',
    'troll face': 'Classic internet antagonism, represents intentional provocation',
    'matrix': 'Philosophical choice between comfortable illusion and difficult truth',
  };

  const lowerQuery = query.toLowerCase();
  for (const [key, sig] of Object.entries(significance)) {
    if (lowerQuery.includes(key)) {
      return sig;
    }
  }
  return 'Cultural significance analysis pending';
}

function getMemeEvolution(query: string): string[] {
  const evolution: Record<string, string[]> = {
    'drake': ['2015: Music video screenshots', '2016: Preference meme format', '2017: Corporate adoption', '2020: Meta-commentary on preferences'],
    'galaxy brain': ['2017: Simple expanding brain', '2018: Universe brain addition', '2019: Ironic intelligence commentary', '2021: Self-aware stupidity'],
    'wojak': ['2010: Sad face character', '2016: Various emotions', '2018: NPC variant', '2020: Soyjak evolution'],
  };

  const lowerQuery = query.toLowerCase();
  for (const [key, evo] of Object.entries(evolution)) {
    if (lowerQuery.includes(key)) {
      return evo;
    }
  }
  return ['Evolution data not available'];
}

function getBestSituations(query: string): string[] {
  const situations: Record<string, string[]> = {
    'drake': ['Binary choices', 'Preference comparisons', 'Before/after scenarios'],
    'galaxy brain': ['Intelligence hierarchies', 'Escalating stupidity', 'Ironic sophistication'],
    'wojak': ['Emotional responses', 'Sadness/frustration', 'NPC behavior mockery'],
    'this is fine': ['Crisis denial', 'Cognitive dissonance', 'Burning situations'],
  };

  const lowerQuery = query.toLowerCase();
  for (const [key, sits] of Object.entries(situations)) {
    if (lowerQuery.includes(key)) {
      return sits;
    }
  }
  return ['Optimal usage situations not catalogued'];
}

function getUsageContext(query: string): string {
  const contexts: Record<string, string> = {
    'drake': 'Use for clear preference statements, especially when contrasting old vs new thinking',
    'galaxy brain': 'Deploy when showing escalating levels of intelligence/stupidity in investor responses',
    'wojak': 'Perfect for emotional manipulation and highlighting investor sadness/confusion',
    'this is fine': 'Ideal for investors in denial about their portfolio or market conditions',
  };

  const lowerQuery = query.toLowerCase();
  for (const [key, context] of Object.entries(contexts)) {
    if (lowerQuery.includes(key)) {
      return context;
    }
  }
  return 'Usage context requires further analysis';
}

function getAudienceReaction(query: string): string {
  const reactions: Record<string, string> = {
    'drake': 'High recognition, immediate understanding, moderate emotional impact',
    'galaxy brain': 'Intellectuals appreciate irony, triggers self-reflection in targets',
    'wojak': 'Strong emotional response, often causes defensive reactions',
    'this is fine': 'Uncomfortable recognition, forces acknowledgment of problems',
  };

  const lowerQuery = query.toLowerCase();
  for (const [key, reaction] of Object.entries(reactions)) {
    if (lowerQuery.includes(key)) {
      return reaction;
    }
  }
  return 'Audience reaction data insufficient';
}
